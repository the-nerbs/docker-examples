# Docker Example 2 - A simple website

This example project demonstrates how you can create and run a web application
from a docker container.

For this example, we use the default project generated by `dotnet new webapp`,
so the interesting parts are all in the Dockerfile.


# Building the Container

Building this image is virtually identical to the console application. Just
 navigate to this directory in your terminal and run the following command:
```
docker build -t serverapp .
```

If you inspect this project's Dockerfile, you may also notice that is looks
very similar to the console applications as well. This is because most of the
hard work is already taken care of for us by the dotnet tooling.

The most significant change is that we take the seemingly-circuitous path of
copying the project file into the container by itself and then restoring our
nuget packages. This is to take advantage of docker's image layer caching,
which can dramatically shorten build times and reduce network overhead by
saving off the results of an earlier restore operation, and only re-running the
restore when the dependencies change.

Since this is also an ASP.NET app instead of a local console tool, we also use
the dedicated ASP.NET base image provided by Microsoft. This is an extension of
the regular .NET Runtime base image (mcr.microsoft.com/dotnet/runtime) which
also includes the ASP.NET runtime libraries.


# Running the Website

From your terminal, run the following command:
```
docker run --name server --publish 8000:80 serverapp
```

There are a couple new arguments being passed to docker here:
- `--name <value>` allows us to specify a meaningful name to the container.
  This name can be used with other docker commands later to interact with it,
  such as stopping and restarting it.

- `--publish 8000:80` (or its short form `-p`) is used to map a port on your
  host environment to one in the docker container. In this case, we're mapping
  port 8000 on our host to port 80 in our container, which is exposed in the
  dockerfile. A different argument, `--publish-all`/`-P` can be used to map all
  of the container's exposed ports to random ports on the host.

Now that the container is running, you should be able to open your favorite web
browser and navigate to http://localhost:8000 to see the website running.


# When should you do this?

Whenever you want!

Running a website, or more generally any web server, is one of the intended use
cases for docker, and is one of the areas it shines brightest.

The advantages of containers when compared to physical or virtual servers are 
numerous, but a few main ones are:
- Lightweight: containers don't require a complete OS for every container you
  want to run.

- Isolation: containers can only communicate with anything outside of them
  using specifically configured ports.

- Resiliency: It's much more difficult to bring down a whole system when
  something goes wrong. As we'll see in the next example, it's also easy to
  configure a container to automatically restart if something crashes it.

- Ease of deployment: Since docker containers are largely built from pre-
  configured images, the manual effort needed to deploy a web application is
  typically little-to-none, and oftentimes can be completely automated if
  desired.
